
üîß Refactoring üîß


üü£ Extract Method

‚ò¢Ô∏è Problem
You have a code fragment that can be grouped together.

void printOwing() {
  printBanner();

  // Print details.
  System.out.println("name: " + name);
  System.out.println("amount: " + getOutstanding());
}

üü¢ Solution
Move this code to a separate new method (or function) and replace the old code with a call to the method.

void printOwing() {
    printBanner();
    printDetails(getOutstanding());
  }
  
  void printDetails(double outstanding) {
    System.out.println("name: " + name);
    System.out.println("amount: " + outstanding);
  }


üü£ Inline Method

‚ò¢Ô∏è Problem
When a method body is more obvious than the method itself, use this technique.

class PizzaDelivery {
  // ...
  int getRating() {
    return moreThanFiveLateDeliveries() ? 2 : 1;
  }
  boolean moreThanFiveLateDeliveries() {
    return numberOfLateDeliveries > 5;
  }
}

üü¢ Solution
Replace calls to the method with the method‚Äôs content and delete the method itself.

class PizzaDelivery {
  // ...
  int getRating() {
    return numberOfLateDeliveries > 5 ? 2 : 1;
  }
}


üü£ Inline Temp

‚ò¢Ô∏è Problem
You have a temporary variable that‚Äôs assigned the result of a simple expression and nothing more.

boolean hasDiscount(Order order) {
  double basePrice = order.basePrice();
  return basePrice > 1000;
}

üü¢ Solution
Replace the references to the variable with the expression itself.

boolean hasDiscount(Order order) {
  return order.basePrice() > 1000;
}


üü£ Substitute Algorithm

‚ò¢Ô∏è Problem
So you want to replace an existing algorithm with a new one?

String foundPerson(String[] people){
  for (int i = 0; i < people.length; i++) {
    if (people[i].equals("Don")){
      return "Don";
    }
    if (people[i].equals("John")){
      return "John";
    }
    if (people[i].equals("Kent")){
      return "Kent";
    }
  }
  return "";
}

üü¢ Solution
Replace the body of the method that implements the algorithm with a new algorithm.

String foundPerson(String[] people){
  List candidates =
    Arrays.asList(new String[] {"Don", "John", "Kent"});
  for (int i=0; i < people.length; i++) {
    if (candidates.contains(people[i])) {
      return people[i];
    }
  }
  return "";
}


üü£ Introduce Foreign Method

‚ò¢Ô∏è Problem
A utility class doesn‚Äôt contain the method that you need and you can‚Äôt add the method to the class.

class Report {
  // ...
  void sendReport() {
    Date nextDay = new Date(previousEnd.getYear(),
      previousEnd.getMonth(), previousEnd.getDate() + 1);
    // ...
  }
}

üü¢ Solution
Add the method to a client class and pass an object of the utility class to it as an argument.

class Report {
  // ...
  void sendReport() {
    Date newStart = nextDay(previousEnd);
    // ...
  }
  private static Date nextDay(Date arg) {
    return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);
  }
}

üü£ Self Encapsulate Field

‚ò¢Ô∏è Problem
You use direct access to private fields inside a class.

class Range {
  private int low, high;
  boolean includes(int arg) {
    return arg >= low && arg <= high;
  }
}

üü¢ Solution
Create a getter and setter for the field, and use only them for accessing the field.

class Range {
  private int low, high;
  boolean includes(int arg) {
    return arg >= getLow() && arg <= getHigh();
  }
  int getLow() {
    return low;
  }
  int getHigh() {
    return high;
  }
}


üü£ Replace Array with Object

‚ò¢Ô∏è Problem
You have an array that contains various types of data.

String[] row = new String[2];
row[0] = "Liverpool";
row[1] = "15";

üü¢ Solution
Replace the array with an object that will have separate fields for each element.

Performance row = new Performance();
row.setName("Liverpool");
row.setWins("15");


üü£ Replace Magic Number with Symbolic Constant

‚ò¢Ô∏è Problem
Your code uses a number that has a certain meaning to it.

double potentialEnergy(double mass, double height) {
  return mass * height * 9.81;
}

üü¢ Solution
Replace this number with a constant that has a human-readable name explaining the meaning of the number.

static final double GRAVITATIONAL_CONSTANT = 9.81;

double potentialEnergy(double mass, double height) {
  return mass * height * GRAVITATIONAL_CONSTANT;
}


üü£ Encapsulate Collection 
= Make the getter-returned value read-only and create methods for adding/deleting elements of the collection.


üü£ Decompose Conditional

‚ò¢Ô∏è Problem
You have a complex conditional (if-then/else or switch).

if (date.before(SUMMER_START) || date.after(SUMMER_END)) {
  charge = quantity * winterRate + winterServiceCharge;
}
else {
  charge = quantity * summerRate;
}

üü¢ Solution
Decompose the complicated parts of the conditional into separate methods: the condition, then and else.

if (isSummer(date)) {
  charge = summerCharge(quantity);
}
else {
  charge = winterCharge(quantity);
}


üü£ Replace Nested Conditional with Guard Clauses

‚ò¢Ô∏è Problem
You have a group of nested conditionals and it‚Äôs hard to determine the normal flow of code execution.

public double getPayAmount() {
  double result;
  if (isDead){
    result = deadAmount();
  }
  else {
    if (isSeparated){
      result = separatedAmount();
    }
    else {
      if (isRetired){
        result = retiredAmount();
      }
      else{
        result = normalPayAmount();
      }
    }
  }
  return result;
}

üü¢ Solution
Isolate all special checks and edge cases into separate clauses and place them before the main checks. 
Ideally, you should have a ‚Äúflat‚Äù list of conditionals, one after the other.

public double getPayAmount() {
  if (isDead){
    return deadAmount();
  }
  if (isSeparated){
    return separatedAmount();
  }
  if (isRetired){
    return retiredAmount();
  }
  return normalPayAmount();
}